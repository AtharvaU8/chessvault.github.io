<!DOCTYPE html>
<html>

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <link rel="stylesheet" href="/css/about.css">
  <link rel="icon" href="/img/trans-castlefile.png" type="image/x-icon" />
  <meta name="description" content="Castle File provides encryption and decryption of any file using chess moves in a gamified way. It can lock and unlock any file having any extensions such as .txt, .docx, .pdf, .jpg etc.">
  <meta name="keywords" content="File Encryption by Chess, Chess Encryption, File lock by chess, Castle File">
  <meta name="author" content="Castle File">
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Quicksand:wght@300;400&display=swap" rel="stylesheet">
  <script src="https://kit.fontawesome.com/fd38fe2beb.js" crossorigin="anonymous"></script>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta2/css/all.min.css"/>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/all.min.css"/>
  
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/9000.0.1/themes/prism-okaidia.min.css" integrity="sha512-5HvW0a7ihK3ro2KhwEksDHXgIezsTeZybZDIn8d8Y015Ny+t7QWSIjnlCTjFzlK7Klb604HLGjsNqU/i5mJLjQ==" crossorigin="anonymous" referrerpolicy="no-referrer" />
  
  
  <title>About</title>
  
</head>

<body>
  <nav class="navbar">

        <div class="max-width">

            <div class="logo">
              <img src="/img/trans-castlefile.png" alt="/img/trans-castlefile.png">
              <a href="#">CastleFile</a>
            </div>
            <div class="menu-btn" id="menu-btn">
                <i class="fas fa-bars"></i>
            </div>
            <ul class="menu">
              <div class="inaclogo">
                <img class="menu-img" src="/img/trans-castlefile.png" alt="/img/trans-castlefile.png">
                <a class="menu-name" href="#">CastleFile</a>
              </div>
                <li><a href="https://castlefile.xyz" class="menu-btn">Home</a></li>
                <li><a href="about" class="menu-btn">About</a></li>
                <li><a href="blog" class="menu-btn">Blog</a></li>
                <li><a href="faq" class="menu-btn">F.A.Q</a></li>
                <li><a href="usage" class="menu-btn">Usage</a></li>
                <li><a href="#contact" class="menu-btn">Contact</a></li>
            </ul>
            
        </div>
  </nav>
  <div class="main">
    
 
     <div class="intro">
        <h1>About</h1>
        <hr />
        <p class="p1">CastleFile is not just another file encryption website—it’s a completely new approach to file security. Traditional encryption methods rely on static passwords or randomly generated keys. CastleFile transforms this paradigm by using chess moves as an essential component of the encryption process. Your moves become the key to securing your files, making the encryption process both unique and highly personalized.</p>
        <p class="p2">CastleFile is a revolutionary platform that brings together the art of chess and cutting-edge encryption technologies to ensure the highest level of security for your files. Designed for individuals and businesses who prioritize privacy and innovation, CastleFile combines your unique chess moves with AES encryption to create an unparalleled data protection system. This page provides an in-depth look at CastleFile, its features, best practices, limitations, and technical details.</p>
        <span>Every interaction on CastleFile is driven by the following core values:</span>
        
        <ul>
          <li>Security: Your data is protected using AES-GCM encryption, ensuring confidentiality and integrity.</li>
          <li>Privacy: Your encryption keys and files are never stored on CastleFile.</li>
          <li>Innovation: By combining chess strategy with cryptographic principles, CastleFile makes encryption both engaging and reliable.</li>
        </ul>
       
      </div>
      
      <div class="features">
        <h1>Features</h1>
        <hr />
        
        <h2>1. Chess Move Integration</h2>
        <ul>
          <li>The encryption and decryption processes are based on the sequence of chess moves you play on a virtual board.</li>
          <li>The moves are transformed into a cryptographic key, ensuring that no two keys are the same.</li>
          <li>The website offers move suggestions for users who are less familiar with chess strategies, helping create strong keys while maintaining user-friendliness.</li>
        </ul>
        
        <h2>2. AES Encryption</h2>
        <ul>
          <li>CastleFile uses the AES-GCM encryption standard, trusted worldwide for its reliability in securing sensitive data.</li>
          <li>The encryption ensures both data confidentiality and integrity, meaning your files cannot be accessed or tampered with.</li>
        </ul>
        
        <h2>3. Security and Privacy</h2>
        <ul>
          <li>CastleFile does not store your files, keys, or data.</li>
          <li>Once the encryption or decryption process is complete, the files are deleted from the system, leaving no trace behind.</li>
          <li>The platform ensures that even CastleFile’s administrators have no access to your data.</li>
        </ul>
        
        <h2>4. Unique and Different</h2>
        <ul>
          <li>Unlike other websites that use static passwords, CastleFile creates a dynamic, personalized encryption process.</li>
          <li>The chess-based system makes brute-force attacks or password guessing virtually impossible, as the number of possible move combinations is astronomical.</li>
        </ul>
      </div>
      
      <div class="practices">
        <h1>Best Practices</h1>
        <hr />
        
        <h2 class="hf">1. Save Your Chess Move Sequence</h2>
        <span >Always securely store the sequence of moves you use for encryption. Without it, decryption will not be possible.</span>
        
        <h2>2. Use Complex Chess Strategies</h2>
        <span>Play more than the minimum 4 moves to enhance the complexity of the encryption key. The more moves you play, the harder it becomes to break the encryption.</span>
        
        <h2>3. Verify File Integrity</h2>
        <span>After encryption, download the file and verify its integrity to ensure the process was successful.</span>
        
        <h2>4. Use Updated Browsers</h2>
        <span class="spanl">Ensure you are using the latest version of your browser for compatibility and security.</span>
        
      </div>
      
      <div class="limitations">
        
        <h1>Limitations</h1>
        <hr />
        
        <h2>1. Dependency on Chess Moves</h2>
        <span>The decryption process requires the exact same chess move sequence as used during encryption. If you lose the sequence, the file cannot be decrypted.</span>
        
        <h2>2. Browser Compatibility</h2>
        <span>Certain features may not work optimally on outdated or unsupported browsers. Mobile users may experience issues with repeated downloads if the browser’s cache is not cleared.</span>
        
        <h2>3. File Size Limitations</h2>
        <span>Currently, CastleFile supports files up to a certain size limit to ensure faster processing and optimal performance.</span>
        
        <h2>4. No Recovery Option</h2>
        <span>For security reasons, CastleFile does not store encryption keys or files. If the chess move sequence is lost, recovery is impossible.</span>
        
      </div>
      
      <div class="tech">
        
        <h1>Technical Details</h1>
        <hr />
        
        
        <h2>1. File Upload: The user uploads a file.</h2>
        <span id="spanf">When the user uploads a file on the CastleFile platform, the process initiates the encryption and decryption workflow.</span>
        <li class="fli">File Selection: The user selects the file they want to encrypt or decrypt from their device using the website's upload interface.</li>
        
        <ul>
          <li>Secure Transfer: The file is uploaded securely to the platform, often using HTTPS to ensure data integrity during the transfer.</li>
          <li>File Handling: The file is processed locally in the browser to prepare it for encryption. No storage of the file occurs, ensuring privacy.</li>
        </ul>
        <span id="spanl">This step serves as the starting point for the encryption process, where the user's file will later be secured using the unique cryptographic key derived from their chess moves.</span>
        
        
        <h2>2. User Plays Chess Moves: They're captured and converted into Encryption Key.</h2>

        <span>This function combines chess moves from both the user and the bot, processes them using a cryptographic hashing algorithm (SHA-256), and generates a unique 256-bit key. This key can then be used in encryption processes, such as AES (Advanced Encryption Standard), to secure files.</span>

      
        <pre>
          <code class="language-javascript">async function generateKeyFromMoves(userMoves, botMoves) {
            const combinedMoves = userMoves.concat(botMoves).join("");
            const msgUint8 = new TextEncoder().encode(combinedMoves);
            const hashBuffer = await crypto.subtle.digest("SHA-256", msgUint8);
            return hashBuffer.slice(0, 32); // AES key requires 256 bits
          }</code>
        </pre>
        <h3>1. Input Data and Combine It:</h3>
        <pre ><code class="language-javascript">const combinedMoves = userMoves.concat(botMoves).join("");</code></pre>
        <ul>
          <li>userMoves: Chess moves played by the user (e.g., ["e2e4", "g1f3"]).</li>
          <li>botMoves: Chess moves played by the bot (e.g., ["e7e5", "b8c6"]).</li>
          <li>userMoves.concat(botMoves): Combines both arrays into a single array of moves.</li>
          <li>.join(""): Joins all moves into a single string without any separators.</li>
        </ul>
        <span>These moves are stored as arrays of strings.</span>
        
        <h3>2. Encoding to Binary Format:</h3>
        <pre ><code class="language-javascript">const msgUint8 = new TextEncoder().encode(combinedMoves);</code></pre>
        <ul>
          <li>New TextEncoder(). encode(combinedMoves): Converts the combined string of moves into a binary format (Uint8Array).</li>
          <li>This ensures the data can be processed by cryptographic algorithms.</li>
        </ul>
        
        
        <h3>3. Hashing the Data:</h3>
        <pre ><code class="language-javascript">const hashBuffer = await crypto.subtle.digest("SHA-256", msgUint8);</code></pre>
        <ul>
          <li>crypto.subtle.digest("SHA-256", msgUint8): Applies the SHA-256 hashing algorithm to the binary data.</li>
          <li>SHA-256 produces a 256-bit (32-byte) cryptographic hash of the input.</li>
          <li>The hash ensures the generated key is unique and deterministic (the same moves will always generate the same key).</li>
        </ul>
        
        
        <h3>4. Extracting the Key:</h3>
        <pre ><code class="language-javascript">return hashBuffer.slice(0, 32); // AES key requires 256 bits</code></pre>
        <ul>
          <li>hashBuffer.slice(0, 32): Extracts the first 32 bytes of the hashed data to match the 256-bit key size required for AES encryption.</li>
        </ul>
        
        
        
        
        <h2>3. File Encryption: The file is encrypted using the generated key.</h2>
        <span>This code demonstrates a JavaScript function, encryptFile, that encrypts a file uploaded by the user using the AES-GCM algorithm.</span>
      
        <pre>
          <code class="language-javascript">async function encryptFile() {
                        
              const fileInput = document.getElementById("fileInput").files[0];
              // Generate encryption key
              const keyBuffer = await generateKeyFromMoves(userMoves, botMoves);
              const key = await crypto.subtle.importKey("raw", keyBuffer, "AES-GCM", false, ["encrypt"]);
              const iv = crypto.getRandomValues(new Uint8Array(12)); // IV for AES-GCM
              const fileData = await fileInput.arrayBuffer();
              const encryptedData = await crypto.subtle.encrypt({ name: "AES-GCM", iv }, key, fileData);
              const combined = new Uint8Array(iv.length + encryptedData.byteLength);
              combined.set(iv);
              combined.set(new Uint8Array(encryptedData), iv.length);
                      
              downloadFile(combined, "castlefile_" + fileInput.name + ".enc.txt");
          }</code>
        </pre>
        <h3>1. File Selection</h3>
        <pre ><code class="language-javascript">const fileInput = document.getElementById("fileInput").files[0];</code></pre>
        <ul>
          <li>The user selects the encrypted file using a file input field with the ID fileInput.</li>
          <li>The file is stored in the fileInput variable for processing.</li>
        </ul>
        
        <h3>2. Generate Encryption Key:</h3>
        <pre ><code class="language-javascript">const keyBuffer = await generateKeyFromMoves(userMoves, botMoves);
const key = await crypto.subtle.importKey("raw", keyBuffer, "AES-GCM", false, ["encrypt"]);</code></pre>
        <ul>
          <li>Uses userMoves (user's chess moves) and botMoves (bot's chess moves) to generate a unique cryptographic key.</li>
          <li>The generateKeyFromMoves function creates a 256-bit key using a SHA-256 hash of the concatenated moves. This ensures the encryption key is unique to the game.</li>
          <li>The generated key is imported for use in AES-GCM encryption using the Web Cryptography API's importKey method.</li>
        </ul>
        
        <h3>3. Generate IV (Initialization Vector):</h3>
        <pre ><code class="language-javascript">const iv = crypto.getRandomValues(new Uint8Array(12));</code></pre>
        <ul>
          <li>Creates a random 12-byte initialization vector (IV) for AES-GCM encryption.</li>
          <li>The IV adds randomness, ensuring the encryption output changes even if the same data and key are reused.</li>
        </ul>
        
        
        <h3>4. Read and Encrypt the File:</h3>
        <pre ><code class="language-javascript">const fileData = await fileInput.arrayBuffer();
const encryptedData = await crypto.subtle.encrypt({ name: "AES-GCM", iv }, key, fileData);</code></pre>
        <ul>
          <li>Reads the file's binary data as an ArrayBuffer, preparing it for encryption.</li>
          <li>Encrypts the file data using the AES-GCM algorithm with the previously generated key and IV.</li>
          <li>The crypto.subtle.encrypt function returns an ArrayBuffer of encrypted data.</li>
        </ul>
        
        <h3>5. Combine IV and Encrypted Data:</h3>
        <pre><code class="language-javascript">const combined = new Uint8Array(iv.length + encryptedData.byteLength);
combined.set(iv);
combined.set(new Uint8Array(encryptedData), iv.length);
</code></pre>
        <ul>
          <li>Merges the IV and encrypted data into a single Uint8Array.</li>
          <li>The IV is stored at the beginning of the array, followed by the encrypted file data. This ensures the IV is available for decryption.</li>
        </ul>
        
        <h3>6. Download the Encrypted File:</h3>
        <pre ><code class="language-javascript">downloadFile(combined, "castlefile_" + fileInput.name + ".enc.txt");</code></pre>
        <ul>
          <li>The downloadFile function triggers the download of the combined data (IV + encrypted file).</li>
          <li>The downloaded file is named with a prefix (castlefile_) to indicate it has been encrypted and appends the .enc.txt extension for identification.</li>
        </ul>
        
        
        <h2>4. File Decryption: The encrypted file is decrypted using the regenerated key.</h2>

        <span>This JavaScript function, decryptFile, is designed to decrypt a file encrypted using the AES-GCM algorithm. It relies on the user-provided and bot-generated chess moves to reconstruct the encryption key, ensuring the correct moves are essential for successful decryption.</span>

      
        <pre>
          <code class="language-javascript">async function decryptFile() {
              const fileInput = document.getElementById("fileInput").files[0];
              const keyBuffer = await generateKeyFromMoves(userMoves, botMoves);
              const key = await crypto.subtle.importKey("raw", keyBuffer, "AES-GCM", false, ["decrypt"]);
              const fileData = await fileInput.arrayBuffer();
              const iv = fileData.slice(0, 12); // First 12 bytes are the IV
              const encryptedData = fileData.slice(12);
    
              try {
                const decryptedData = await crypto.subtle.decrypt({ name: "AES-GCM", iv: new Uint8Array(iv) }, key, encryptedData);
                downloadFile(decryptedData, fileInput.name.replace(".enc.txt", ""));
                
              } catch (error) {
                console.log(error);
              }
          }</code>
        </pre>
        <h3>1. Retrieve the File to Decrypt:</h3>
        <pre class="code" ><code class="language-javascript">const fileInput = document.getElementById("fileInput").files[0];</code></pre>
        <ul>
          <li>The user selects the encrypted file using a file input field with the ID fileInput.</li>
          <li>The file is stored in the fileInput variable for processing.</li>
        </ul>
        
        <h3>2. Generate the Decryption Key:</h3>
        <pre><code class="language-javascript">const keyBuffer = await generateKeyFromMoves(userMoves, botMoves);
const key = await crypto.subtle.importKey("raw", keyBuffer, "AES-GCM", false, ["decrypt"]);</code></pre>
        <ul>
          <li>Uses userMoves (user's chess moves) and botMoves (bot's chess moves) to generate a unique cryptographic key.</li>
          <li>The generateKeyFromMoves function creates a 256-bit key using a SHA-256 hash of the concatenated chess moves from the user and the bot.</li>
          <li>The resulting key is imported using the Web Cryptography API's importKey function to be used in the decryption process.</li>
        </ul>
        
        <h3>3. Read and Separate the File Data:</h3>
        <pre><code class="language-javascript">const fileData = await fileInput.arrayBuffer();
const iv = fileData.slice(0, 12); // First 12 bytes are the IV
const encryptedData = fileData.slice(12);</code></pre>
        <ul>
          <li>Reads the encrypted file into an ArrayBuffer.</li>
          <li>Extracts the first 12 bytes as the Initialization Vector (IV), which was prepended during encryption.</li>
          <li>Separates the remaining data as the encrypted content.</li>
        </ul>
        
        
        <h3>4. Decrypt the File:</h3>
        <pre><code class="language-javascript">const decryptedData = await crypto.subtle.decrypt({ name: "AES-GCM", iv: new Uint8Array(iv) }, key, encryptedData);</code></pre>
        <ul>
          <li>Decrypts the encrypted data using the crypto.subtle.decrypt function.</li>
          <li>Passes the AES-GCM decryption algorithm, IV, decryption key, and the encrypted data as inputs.</li>
          <li>If the key, IV, or encrypted data are incorrect, decryption will fail and throw an error.</li>
        </ul>
        
        
        <h3>5. Download the Decrypted File:</h3>
        <pre><code class="language-javascript">downloadFile(decryptedData, fileInput.name.replace(".enc.txt", ""));</code></pre>
        <ul>
          <li>The downloadFile function triggers the download of the decrypted data.</li>
          <li>Renames the file by removing the .enc.txt extension, restoring the original file name.</li>
        </ul>
       
       <h3>6. Handle Errors:</h3>

        <pre><code class="language-javascript">
catch (error) {
  console.log(error);
}</code></pre>

        <ul>
          <li>If decryption fails (due to an incorrect key, IV, or corrupted data), an error message is displayed to the user.</li>
          <li>The error hints that the user must replay the same chess moves during decryption as were used for encryption to regenerate the correct key.</li>
        </ul>
       
        
        <h2>5. Download: The Encrypted or Decrypted file is Downloaded.</h2>

        <span>This JavaScript function, downloadFile, handles the task of downloading a file from the browser. It takes two parameters: the data to be downloaded and the filename to save it as. </span>
        <pre>
          <code class="language-javascript">function downloadFile(data, filename) {
            try {
                const blob = new Blob([data], { type: "application/octet-stream" });
                const url = URL.createObjectURL(blob);
        
                // Trigger download
                const a = document.createElement("a");
                a.href = url;
                a.download = filename;
                document.body.appendChild(a);
                a.click();
        
                // Clean up
                document.body.removeChild(a);
                URL.revokeObjectURL(url); // Revoke the Blob URL after use
                
            } catch (error) {
                console.error("Download error:", error);
            }
          }</code>
        </pre>
        <h3>1. Create a Blob:</h3>
        <pre><code class="language-javascript">const blob = new Blob([data], { type: "application/octet-stream" });</code></pre>
        <ul>
          <li>A Blob (Binary Large Object) is created to encapsulate the data to be downloaded.</li>
          <li>The type: "application/octet-stream" ensures the browser treats the file as raw binary data suitable for downloading.</li>
        </ul>
        
        <h3>2. Generate a Blob URL and Create a Hidden <'a'> Element:</h3>
        <pre ><code class="language-javascript">const url = URL.createObjectURL(blob);</code></pre>
        <ul>
          <li>The URL.createObjectURL method generates a temporary URL pointing to the Blob. This URL can be used to access the Blob data, which is valid for the current browser session.</li>
          <li>A hidden <'a'> (anchor) element is dynamically created. This element is used to trigger the file download.</li>
        </ul>
        
        <h3>3. Assign Blob URL and Filename:</h3>
        <pre ><code class="language-javascript">a.href = url;
a.download = filename;</code></pre>
        <ul>
          <li>The href of the anchor element is set to the Blob URL.</li>
          <li>The download attribute specifies the name of the file that will be saved on the user’s system.</li>
        </ul>
        
        
        <h3>4. Trigger the Download:</h3>
        <pre ><code class="language-javascript">document.body.appendChild(a);
a.click();</code></pre>
        <ul>
          <li>The anchor element is temporarily added to the document body to make it part of the DOM.</li>
          <li>The click() method programmatically simulates a user click, triggering the file download.</li>
        </ul>
        
        
        <h3>5. Clean Up Resources:</h3>
        <pre ><code class="language-javascript">document.body.removeChild(a);
URL.revokeObjectURL(url);</code></pre>
        <ul>
          <li>After the download begins, the anchor element is removed from the DOM to keep the document clean.</li>
          <li>The Blob URL is revoked using URL.revokeObjectURL(url) to free up memory, as Blob URLs consume resources.</li>
        </ul>
       
        <h3>6. Handle Errors:</h3>

        <pre ><code class="language-javascript">
catch (error) {
  console.log(error);
}</code></pre>

        <ul>
          <li>If decryption fails (due to an incorrect key, IV, or corrupted data), an error message is displayed to the user.</li>
          <li>The error hints that the user must replay the same chess moves during decryption as were used for encryption to regenerate the correct key.</li>
        </ul>
       
       
      </div>
      
      
      
      
    
  </div>
   
   
  
  <footer id="footer">
          <div class="row primary">
            <div class="column about">
              <h3 class="namehead">Castle File</h3>
              <p>
                Castle File provides encryption and decryption of any file using chess moves in a gamified way for free. It can lock and unlock any file having any extensions such as .txt, .docx, .pdf, .jpg etc. It provides mechanism to encrypt the file with your own style of playing chess. This ensures the utmost security and privacy of your file in an unique and innovative way.
              </p>
            </div>
            <div class="column links">
              <h3 class="quickhead">Quick Links</h3>
              <ul>
                <li>
                  <a href="https://castlefile.xyz/">Home</a>
                </li>
                <li>
                  <a href="about">About</a>
                </li>
                <li>
                  <a href="blog">Blog</a>
                </li>
                <li>
                  <a href="faq">F.A.Q</a>
                </li>
                <li>
                  <a href="usage">Usage</a>
                </li>
                <li>
                  <a href="https://atharva-portfolio.netlify.app/">Personal Portfolio</a>
                </li>
              </ul>
            </div>
            <div class="column subscribe" id="contact">
              <h3 class="followhead">Follow Us</h3>
              <div class="social">
		            <a href="https://www.reddit.com/user/Suitable_Economy_463/"><i id="youtube" class="fa-brands fa-reddit"></i></a>
		              <a href="https://www.producthunt.com/@atharvaugale8"><i id="youtube" class="fa fa-product-hunt"></i></a>
                <a href="https://www.instagram.com/atharvaugale8/"><i id="instagram" class="fa-brands fa-instagram"></i></a>
                <a href="https://github.com/AtharvaU8/"><i id="github" class="fa-brands fa-github"></i></a>
                <a href="https://atharva-portfolio.netlify.app/"><i id="user" class="fa fa-link"></i></a>
              </div>
            </div>
          </div>
          <div class="row copyright">
            <p>Copyright &copy; 2024 Castle File | All Rights Reserved</p>
            <a id="made" href="https://atharva-portfolio.netlify.app/">~ Made by Atharva</a>
          </div>
   </footer>
  
  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/9000.0.1/prism.min.js" integrity="sha512-UOoJElONeUNzQbbKQbjldDf9MwOHqxNz49NNJJ1d90yp+X9edsHyJoAs6O4K19CZGaIdjI5ohK+O2y5lBTW6uQ==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
  <script src="/js/page.js"></script>
</body>
</html>
